import { Message, Client } from 'whatsapp-web.js';
import { ClientService, ServiceService, AppointmentService, ConversationService } from '../services/database.service';
import { logger } from '../utils/logger';
import { format, addDays, isAfter, isBefore, startOfDay } from 'date-fns';

interface BookingData {
  step: 'initial' | 'waiting_name' | 'selecting_service' | 'selecting_date' | 'selecting_time' | 'confirming';
  name?: string;
  selectedService?: number;
  selectedDate?: string;
  selectedTime?: string;
}

export class WhatsAppMessageHandler {
  private clientService: ClientService;
  private serviceService: ServiceService;
  private appointmentService: AppointmentService;
  private conversationService: ConversationService;

  constructor() {
    this.clientService = new ClientService();
    this.serviceService = new ServiceService();
    this.appointmentService = new AppointmentService();
    this.conversationService = new ConversationService();
  }

  async handleMessage(message: Message, client: Client): Promise<void> {
    // Ignorar mensagens de grupos e pr√≥prias mensagens
    if (message.from.includes('@g.us') || message.fromMe) {
      return;
    }

    const phoneNumber = message.from.replace('@c.us', '');
    const messageText = message.body.toLowerCase().trim();

    logger.info(`Mensagem recebida de ${phoneNumber}: ${message.body}`);

    try {
      // Verificar se existe conversa em andamento
      const conversationState = await this.conversationService.getConversationState(phoneNumber);
      
      // Comando para cancelar agendamento
      if (messageText === '/cancelar' || messageText === 'cancelar' || messageText === '"cancelar"') {
        await this.conversationService.clearConversationState(phoneNumber);
        await this.sendMessage(client, message.from, 
          '‚ùå Agendamento cancelado. Digite "agendar" para come√ßar novamente.');
        return;
      }

      // Iniciar agendamento apenas com comando espec√≠fico
      if (messageText === '/agendar' || messageText === 'agendar' || messageText === '"agendar"') {
        await this.startBookingFlow(client, message.from, phoneNumber);
        return;
      }

      // Continuar conversa em andamento
      if (conversationState) {
        await this.continueBookingFlow(client, message.from, phoneNumber, messageText, conversationState);
        return;
      }

      // Comandos informativos (sem iniciar agendamento)
      if (messageText === '/info' || messageText === 'info' || messageText === '"info"') {
        await this.sendSalonInfo(client, message.from);
        return;
      }

      if (messageText === '/endereco' || messageText === 'endereco' || messageText === 'endere√ßo' || messageText === '"endereco"') {
        await this.sendSalonAddress(client, message.from);
        return;
      }

      if (messageText === '/contato' || messageText === 'contato' || messageText === '"contato"') {
        await this.sendSalonContact(client, message.from);
        return;
      }

      if (messageText === '/help' || messageText === 'help' || messageText === 'ajuda' || messageText === '"help"') {
        await this.sendHelpMenu(client, message.from);
        return;
      }

      // Resposta padr√£o para mensagens n√£o reconhecidas
      await this.sendMessage(client, message.from, 
        `üòä Ol√°! Para fazer um agendamento, digite: *agendar*\n\nOutros comandos dispon√≠veis:\nüìã *info* - Informa√ß√µes do sal√£o\nüìç *endereco* - Nosso endere√ßo\nüìû *contato* - Formas de contato\n‚ùì *help* - Ajuda`);
      return;

    } catch (error) {
      logger.error('Erro ao processar mensagem:', error);
      await this.sendMessage(client, message.from, 
        '‚ùå Ocorreu um erro. Tente novamente ou digite "agendar" para come√ßar.');
    }
  }

  private async sendMessage(client: Client, to: string, text: string): Promise<void> {
    try {
      await client.sendMessage(to, text);
    } catch (error) {
      logger.error('Erro ao enviar mensagem:', error);
    }
  }

  private async sendMainMenu(client: Client, to: string): Promise<void> {
    const menuText = `
üå∏ *Bem-vindo(a) ao ${process.env.SALON_NAME || 'Sal√£o de Beleza'}!* üå∏

Para agendar um servi√ßo, digite:
üìÖ *"agendar"* - Fazer novo agendamento

Outras op√ß√µes:
‚ÑπÔ∏è *"info"* - Informa√ß√µes do sal√£o
üìç *"endereco"* - Nosso endere√ßo
üìû *"contato"* - Formas de contato

_Digite a op√ß√£o desejada ou "agendar" para come√ßar_`;

    await this.sendMessage(client, to, menuText);
  }

  private async startBookingFlow(client: Client, to: string, phoneNumber: string): Promise<void> {
    // Verificar se cliente j√° existe
    let existingClient = await this.clientService.getClientByWhatsApp(phoneNumber);
    
    if (existingClient) {
      // Cliente existe, pular para sele√ß√£o de servi√ßo
      const services = await this.serviceService.getAllActiveServices();
      
      await this.conversationService.saveConversationState(phoneNumber, 'selecting_service', {
        step: 'selecting_service'
      });

      let serviceText = `Ol√° *${existingClient.name}*! üòä\n\n`;
      serviceText += `üìã *Escolha um servi√ßo:*\n\n`;
      
      services.forEach((service, index) => {
        serviceText += `${index + 1}. *${service.name}*\n`;
        serviceText += `   R$ ${service.price.toFixed(2)} | ‚è∞ ${service.duration_minutes}min\n`;
        if (service.description) {
          serviceText += `   _${service.description}_\n`;
        }
        serviceText += `\n`;
      });
      
      serviceText += `Digite o *n√∫mero* do servi√ßo desejado ou /cancelar para sair.`;
      
      await this.sendMessage(client, to, serviceText);
    } else {
      // Cliente novo, pedir nome
      await this.conversationService.saveConversationState(phoneNumber, 'waiting_name', {
        step: 'waiting_name'
      });

      const welcomeText = `
üå∏ *Seja bem-vindo(a) ao ${process.env.SALON_NAME || 'Sal√£o de Beleza'}!* üå∏

Para fazer seu agendamento, preciso de algumas informa√ß√µes.

*Como posso te chamar?* 
Digite seu nome completo:`;

      await this.sendMessage(client, to, welcomeText);
    }
  }

  private async continueBookingFlow(
    client: Client, 
    to: string, 
    phoneNumber: string, 
    messageText: string, 
    conversationState: any
  ): Promise<void> {
    const currentData: BookingData = conversationState.data ? JSON.parse(conversationState.data) : {};
    
    switch (conversationState.current_step) {
      case 'waiting_name':
        await this.handleNameInput(client, to, phoneNumber, messageText);
        break;
      
      case 'selecting_service':
        await this.handleServiceSelection(client, to, phoneNumber, messageText, currentData);
        break;
      
      case 'selecting_date':
        await this.handleDateSelection(client, to, phoneNumber, messageText, currentData);
        break;
      
      case 'selecting_time':
        await this.handleTimeSelection(client, to, phoneNumber, messageText, currentData);
        break;
      
      case 'confirming':
        await this.handleConfirmation(client, to, phoneNumber, messageText, currentData);
        break;
    }
  }

  private async handleNameInput(client: Client, to: string, phoneNumber: string, name: string): Promise<void> {
    if (name.length < 2) {
      await this.sendMessage(client, to, '‚ùå Por favor, digite um nome v√°lido:');
      return;
    }

    // Criar cliente
    await this.clientService.createClient(phoneNumber, name);
    
    // Mostrar servi√ßos
    const services = await this.serviceService.getAllActiveServices();
    
    await this.conversationService.saveConversationState(phoneNumber, 'selecting_service', {
      step: 'selecting_service'
    });

    let serviceText = `Obrigado *${name}*! üòä\n\n`;
    serviceText += `üìã *Escolha um servi√ßo:*\n\n`;
    
    services.forEach((service, index) => {
      serviceText += `${index + 1}. *${service.name}*\n`;
      serviceText += `   R$ ${service.price.toFixed(2)} | ‚è∞ ${service.duration_minutes}min\n`;
      if (service.description) {
        serviceText += `   _${service.description}_\n`;
      }
      serviceText += `\n`;
    });
    
    serviceText += `Digite o *n√∫mero* do servi√ßo desejado ou /cancelar para sair.`;
    
    await this.sendMessage(client, to, serviceText);
  }

  private async handleServiceSelection(
    client: Client, 
    to: string, 
    phoneNumber: string, 
    messageText: string, 
    currentData: BookingData
  ): Promise<void> {
    const serviceIndex = parseInt(messageText) - 1;
    const services = await this.serviceService.getAllActiveServices();
    
    if (isNaN(serviceIndex) || serviceIndex < 0 || serviceIndex >= services.length) {
      await this.sendMessage(client, to, '‚ùå N√∫mero inv√°lido. Digite um n√∫mero da lista de servi√ßos:');
      return;
    }

    const selectedService = services[serviceIndex];
    
    await this.conversationService.saveConversationState(phoneNumber, 'selecting_date', {
      ...currentData,
      step: 'selecting_date',
      selectedService: selectedService.id
    });

    const dateText = `
‚úÖ *${selectedService.name}* selecionado!
üí∞ Valor: R$ ${selectedService.price.toFixed(2)}
‚è∞ Dura√ß√£o: ${selectedService.duration_minutes} minutos

üìÖ *Escolha uma data:*

${this.getAvailableDatesText()}

Digite a data no formato *DD/MM/AAAA* ou /cancelar para sair.`;

    await this.sendMessage(client, to, dateText);
  }

  private async handleDateSelection(
    client: Client, 
    to: string, 
    phoneNumber: string, 
    messageText: string, 
    currentData: BookingData
  ): Promise<void> {
    const dateRegex = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/;
    const match = messageText.match(dateRegex);
    
    if (!match) {
      await this.sendMessage(client, to, '‚ùå Formato de data inv√°lido. Use DD/MM/AAAA (exemplo: 25/12/2024):');
      return;
    }

    const [, day, month, year] = match;
    const selectedDate = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
    
    // Validar se a data √© futura
    const today = startOfDay(new Date());
    const appointmentDate = new Date(selectedDate);
    
    if (isBefore(appointmentDate, today)) {
      await this.sendMessage(client, to, '‚ùå N√£o √© poss√≠vel agendar para datas passadas. Escolha uma data futura:');
      return;
    }

    await this.conversationService.saveConversationState(phoneNumber, 'selecting_time', {
      ...currentData,
      step: 'selecting_time',
      selectedDate: selectedDate
    });

    const timeText = `
üìÖ Data selecionada: *${day}/${month}/${year}*

‚è∞ *Escolha um hor√°rio dispon√≠vel:*

${await this.getAvailableTimesText(selectedDate)}

Digite o hor√°rio desejado (exemplo: 14:00) ou /cancelar para sair.`;

    await this.sendMessage(client, to, timeText);
  }

  private async handleTimeSelection(
    client: Client, 
    to: string, 
    phoneNumber: string, 
    messageText: string, 
    currentData: BookingData
  ): Promise<void> {
    const timeRegex = /^(\d{1,2}):(\d{2})$/;
    const match = messageText.match(timeRegex);
    
    if (!match) {
      await this.sendMessage(client, to, '‚ùå Formato de hor√°rio inv√°lido. Use HH:MM (exemplo: 14:00):');
      return;
    }

    const selectedTime = match[0];
    
    // Verificar se o hor√°rio est√° dispon√≠vel
    if (!currentData.selectedService) {
      await this.sendMessage(client, to, '‚ùå Erro interno. Reinicie o agendamento com /agendar');
      return;
    }

    const isAvailable = await this.appointmentService.isTimeSlotAvailable(
      currentData.selectedDate!, 
      selectedTime, 
      currentData.selectedService
    );

    if (!isAvailable) {
      await this.sendMessage(client, to, '‚ùå Este hor√°rio n√£o est√° dispon√≠vel. Escolha outro hor√°rio:');
      return;
    }

    await this.conversationService.saveConversationState(phoneNumber, 'confirming', {
      ...currentData,
      step: 'confirming',
      selectedTime: selectedTime
    });

    // Buscar dados do servi√ßo e cliente para confirma√ß√£o
    const service = await this.serviceService.getServiceById(currentData.selectedService);
    const client_data = await this.clientService.getClientByWhatsApp(phoneNumber);
    
    const confirmationText = `
‚úÖ *Confirme seu agendamento:*

üë§ *Nome:* ${client_data?.name}
üíÖ *Servi√ßo:* ${service?.name}
üí∞ *Valor:* R$ ${service?.price.toFixed(2)}
üìÖ *Data:* ${currentData.selectedDate?.split('-').reverse().join('/')}
‚è∞ *Hor√°rio:* ${selectedTime}
‚è±Ô∏è *Dura√ß√£o:* ${service?.duration_minutes} minutos

Digite *CONFIRMAR* para finalizar ou *CANCELAR* para sair.`;

    await this.sendMessage(client, to, confirmationText);
  }

  private async handleConfirmation(
    client: Client, 
    to: string, 
    phoneNumber: string, 
    messageText: string, 
    currentData: BookingData
  ): Promise<void> {
    if (messageText === 'confirmar') {
      // Criar agendamento
      const client_data = await this.clientService.getClientByWhatsApp(phoneNumber);
      
      if (!client_data || !currentData.selectedService || !currentData.selectedDate || !currentData.selectedTime) {
        await this.sendMessage(client, to, '‚ùå Erro nos dados. Reinicie com /agendar');
        return;
      }

      await this.appointmentService.createAppointment({
        client_id: client_data.id,
        service_id: currentData.selectedService,
        appointment_date: currentData.selectedDate,
        appointment_time: currentData.selectedTime,
        status: 'confirmed'
      });

      await this.conversationService.clearConversationState(phoneNumber);

      const service = await this.serviceService.getServiceById(currentData.selectedService);
      
      const successText = `
üéâ *Agendamento confirmado com sucesso!*

üìã *Resumo do seu agendamento:*
üë§ ${client_data.name}
üíÖ ${service?.name}
üìÖ ${currentData.selectedDate.split('-').reverse().join('/')}
‚è∞ ${currentData.selectedTime}
üí∞ R$ ${service?.price.toFixed(2)}

üìç *${process.env.SALON_NAME || 'Sal√£o de Beleza'}*
üìû Entre em contato se precisar reagendar ou cancelar.

_Aguardamos voc√™! üíÑ‚ú®_`;

      await this.sendMessage(client, to, successText);

    } else if (messageText === 'cancelar') {
      await this.conversationService.clearConversationState(phoneNumber);
      await this.sendMessage(client, to, '‚ùå Agendamento cancelado. Digite /agendar para tentar novamente.');
    } else {
      await this.sendMessage(client, to, 'Digite *CONFIRMAR* para finalizar ou *CANCELAR* para sair.');
    }
  }

  private getAvailableDatesText(): string {
    let datesText = '';
    const today = new Date();
    
    for (let i = 1; i <= 14; i++) { // Pr√≥ximos 14 dias
      const date = addDays(today, i);
      const dayOfWeek = date.getDay();
      
      // Verificar dias de funcionamento (configur√°vel)
      const businessDays = process.env.BUSINESS_DAYS?.split(',').map(d => parseInt(d)) || [1,2,3,4,5,6];
      
      if (businessDays.includes(dayOfWeek)) {
        const formattedDate = format(date, 'dd/MM/yyyy');
        const weekDay = format(date, 'EEEE', { locale: undefined }); // Voc√™ pode adicionar locale pt-BR
        datesText += `üìÖ ${formattedDate} (${weekDay})\n`;
      }
    }
    
    return datesText;
  }

  private async getAvailableTimesText(date: string): Promise<string> {
    const startHour = parseInt(process.env.BUSINESS_START_HOUR || '8');
    const endHour = parseInt(process.env.BUSINESS_END_HOUR || '18');
    
    let timesText = '';
    
    for (let hour = startHour; hour < endHour; hour++) {
      for (let minute = 0; minute < 60; minute += 60) { // Intervalos de 1 hora
        const time = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
        timesText += `‚è∞ ${time}\n`;
      }
    }
    
    timesText += '\n_Os hor√°rios mostrados s√£o exemplos. A disponibilidade real ser√° verificada._';
    
    return timesText;
  }

  // M√©todos informativos (n√£o iniciam agendamento)
  private async sendSalonInfo(client: Client, to: string): Promise<void> {
    const infoText = `
‚ÑπÔ∏è *Informa√ß√µes do ${process.env.SALON_NAME || 'Sal√£o de Beleza'}*

üïê *Hor√°rio de Funcionamento:*
Segunda a S√°bado: ${process.env.BUSINESS_START_HOUR || '8'}h √†s ${process.env.BUSINESS_END_HOUR || '18'}h

üíÖ *Nossos Servi√ßos:*
‚Ä¢ Cortes femininos e masculinos
‚Ä¢ Escova e hidrata√ß√£o
‚Ä¢ Manicure e pedicure
‚Ä¢ Design de sobrancelha
‚Ä¢ Colora√ß√£o e luzes

Para agendar, digite: */agendar*`;

    await this.sendMessage(client, to, infoText);
  }

  private async sendSalonAddress(client: Client, to: string): Promise<void> {
    const addressText = `
üìç *Nosso Endere√ßo:*

${process.env.SALON_NAME || 'Sal√£o de Beleza'}
Rua das Flores, 123 - Centro
CEP: 14000-000
Ribeir√£o Preto - SP

üöó *Como Chegar:*
Pr√≥ximo ao Shopping Center
Estacionamento gratuito dispon√≠vel

Para agendar, digite: */agendar*`;

    await this.sendMessage(client, to, addressText);
  }

  private async sendSalonContact(client: Client, to: string): Promise<void> {
    const contactText = `
üìû *Formas de Contato:*

üì± WhatsApp: ${process.env.SALON_PHONE || '(16) 99999-9999'}
üìû Telefone: (16) 3333-4444
üìß Email: contato@salao.com.br
üåê Instagram: @seusalao

üïê *Atendimento:*
Segunda a S√°bado: ${process.env.BUSINESS_START_HOUR || '8'}h √†s ${process.env.BUSINESS_END_HOUR || '18'}h

Para agendar pelo WhatsApp, digite: */agendar*`;

    await this.sendMessage(client, to, contactText);
  }

  private async sendHelpMenu(client: Client, to: string): Promise<void> {
    const helpText = `
‚ùì *Menu de Ajuda - ${process.env.SALON_NAME || 'Sal√£o de Beleza'}*

*Comandos Dispon√≠veis:*
üìÖ */agendar* - Fazer novo agendamento
‚ÑπÔ∏è */info* - Informa√ß√µes do sal√£o  
üìç */endereco* - Nosso endere√ßo
üìû */contato* - Formas de contato
‚ùå */cancelar* - Cancelar agendamento em andamento

*Como Agendar:*
1. Digite */agendar*
2. Informe seu nome (se for primeira vez)
3. Escolha o servi√ßo desejado
4. Selecione a data (formato DD/MM/AAAA)
5. Escolha o hor√°rio
6. Confirme o agendamento

*D√∫vidas?*
Entre em contato: ${process.env.SALON_PHONE || '(16) 99999-9999'}`;

    await this.sendMessage(client, to, helpText);
  }
}